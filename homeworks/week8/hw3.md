## 什麼是 Ajax？

全名 **Asynchronous JavaScript and XML**，也就是非同步的 JavaScript 跟 XML。
JavaScript 應該大家都很熟了，而非同步的 JavaScript 是什麼意思？XML 又是什麼呢？跟 HTML 有什麼關係嗎？
XML 其實跟 HTML 很像，都是標記語言，差別在於，HTML 是用來表現資料，而 XML 則是為了傳遞及攜帶資料而設計。
事實上雖然 Ajax 這個名稱裡面包含 XML，但其實並不局限於 XML，更常使用的格式是 JSON，甚至開始有了 Ajaj 的說法。

而 Ajax 最精華的部分就在於開頭那個大寫的 A -- asynchronous，
在 JavaScript 執行的時候，有分為同步執行跟非同步執行兩種，英文分別是 synchronous 及 asynchronous（只差一個 a，親像天佮地）。
同步執行就是每個動作在執行之前都要等上一個動作結束，也就是乖乖排隊，一個一個來！
而非同步執行則是，這個動作開始了之後，直接開始下一個動作，沒有人在乎他結束了沒（可憐哪）。

就像是我們去便利商店的時候，負責結帳的店員只有一個，卻同時有十個客人在櫃台排隊結帳，
當店員在幫第一個客人結帳時，後面的人就只能等他結完帳才換下一個（同步）。
但現在的便利商店真的不愧對他的名子，什麼事都可以辦到，特別的便利，
有些客人可能要取貨，有些客人還要來一杯中熱美，而這些要求都需要一段時間才能夠完成，再交給客人，
這時候如果還是同步執行的話，後面的客人就只能乾等，整個櫃台正常機能停擺，就為了一杯中熱美。
所以這時候就會改成非同步執行，結帳店員收到客人想要中熱美的要求之後，轉達給有咖啡師證照的小美讓他去煮咖啡，
自己幫客人結完帳之後就不理他們，繼續幫下一個客人結帳，如此一來，就可以有效率的幫全部的客人結帳。

在網路的世界也是一樣的，客人就是使用者，結帳店員就是瀏覽器，有咖啡師證照的小美則是某個伺服器（假設是 Google 伺服器）。
當使用者用瀏覽器在 Google 首頁輸入要搜尋的關鍵字並送出，瀏覽器就會發出 Request 到 Google 伺服器，請他去搜尋這個關鍵字，
這時候你還是可以點擊瀏覽器的任何地方，而且會照樣正常運作，瀏覽器並不會等到 Google 伺服器把搜尋結果傳送回來才讓使用者可以做其他事，
這就是非同步執行，如果全部的動作都是同步執行的話，在 Google 伺服器傳送搜尋結果回來之前，你的瀏覽器就會像當機一樣，按什麼都沒有反應。

個人覺得同步跟非同步在字面上的意思蠻不直覺的，但其實只要把使用情境代入，就可以很好理解分別的意思，至於到底哪個是同步哪個是非同步，忘記了就 Google 吧！

## 用 Ajax 與我們用表單送出資料的差別在哪？

用表單送出資料後，伺服器處理後會回傳一個新的網頁，使用者瀏覽器就會跳轉到該新頁面，但有時候我們並不需要那些多餘的 HTML，只需要必須的資料。
Ajax 可以向伺服器傳送請求後，只拿到必要的資料，JavaScript 可以自己決定要如何處理這些資料，有效節省使用者跟伺服器之間的溝通時間，更減輕了伺服器端的負擔。

## JSONP 是什麼？

#### JSON witch Padding
利用 `<script>` 或是 `<img>` 等這樣不會被同源政策限制的標籤來獲取資料。
**同源政策**是指，在瀏覽器上，因為安全性問題，在發送請求並拿到伺服器回應之後，
瀏覽器會比較使用者跟伺服器的 URL，如果網域、協定、埠號相同都相同，才會同意把回應給使用者。

假設有一個會回傳 JSON 格式資料的 URL，我們可以直接在 `<script src="<API_URL>">` 來繞過同源政策，獲得伺服器的回應。
通常伺服器端會提供一個參數給使用者使用，只要把代入參數的值當作函式名稱，就可以把回應傳到函式裡面
例如有一個 URL 長這樣：`http://api.example.com/data?callbacl=getResponse`
我們就可以用下面的程式碼，來把伺服器的回應在 console 裡面印出來
```
<script src="http://api.example.com/data?callbacl=getResponse"></script>
<script>
  function getResponse(response) {
    console.log(response)
  }
</script>
```
但也因為這個方法只能用 GET 來對伺服器發送請求，所以想用其他的方法來 Request（像是 POST、PUT、DELETE…）是做不到的。

## 要如何存取跨網域的 API？

因為同源政策的關係，不同網域、協定或埠號在發送請求時，受到了相當大的限制，但我們常常需要使用到不同來源的資源，不希望受到這樣的限制。
除了使用 JSONP 這種不受同源政策限制的方法之外，還是有方法可以直接正面讓同源政策同意你從不同來源得到 Response 的

#### CORS(Cross-Origin Resource Sharing)
跨來源資源共用，允許伺服器端在 Response 的 header 裡面加上 `Access-Control-Allow-Oring`，
只要 Request 的來源有包含在 `Access-Control-Allow-Oring` 裡面，就表示伺服器允許這個來源進行跨來源存取，
簡單來說就是伺服器的白名單啦！伺服器可以在 `Access-Control-Allow-Oring` 裡面放入允許得到他們家 Response 的不同網域、不同協定或不同埠號。

#### Preflight Request
Request 又分為**簡單請求**和**預檢請求**，先說說簡單請求好了
簡單請求的定義不太簡單，簡單來說就是 method 如果是 GET，而且沒有自定義的 Headers，就一定是簡單請求（當然不只這樣），
而如果有加入自定義的 Headers，就很有可能不是簡單請求。
預檢請求會先用 OPTIONS 方法送出 Request，來確認之後實際的 Request 可以安全送出，如果第一個 Request 都過不了關的話，實際的 Request 就不用送出了。
前面在 JSONP 有說到，不論 Request 是不是有通過同源政策，伺服器都會收到 Request 並回傳 Response（若中途沒有任何錯誤），會阻止使用者拿到 Response 的是瀏覽器自己把他擋下來了，所以如果今天是一個要刪除資料的 Request 發送出去，伺服器端收到之後回傳 Response，到瀏覽器時才發現這個 Request 沒有通過同源政策已經來不及了，資料已經刪除，回不去了，所以才需要先檢查請求能不能送出。

## 為什麼我們在第四週時沒碰到跨網域的問題，這週卻碰到了？

因為同源政策只發生在瀏覽器，而第四週的時候我們用的是 Node.js 來發送 Request，沒有透過瀏覽器，所以沒有問題。
而這週的 Request 則是由瀏覽器送出，所以會受到同源政策的限制，因為 hw1 跟 hw2 需要串接的 API 都有加入 `Access-Control-Allow-Oring: *`，允許**所有**來源跨網域存取。